package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"
)

func scanWords(data []byte, atEOF bool) (int, []byte, error) {

	// Characters to allow when surrounded by letters:
	// - ’

	if !utf8.FullRune(data) {
		return 0, nil, nil
	}
	i := 0
	for utf8.FullRune(data[i:]) {
		r, l := utf8.DecodeRune(data[i:])
		if unicode.IsLetter(r) || unicode.IsNumber(r) {
			break
		}
		i += l
	}
	if i > 0 {
		return i, nil, nil
	}
	token := []byte(nil)
	maybe := false
	maybeChar := rune(0)
	completeToken := false
	for utf8.FullRune(data[i:]) {
		r, l := utf8.DecodeRune(data[i:])
		if unicode.IsLetter(r) || unicode.IsNumber(r) {
			if maybe {
				token = append(token, string(maybeChar)...)
				maybe = false
			}
			token = append(token, string(r)...)
		} else if (r == '-') || (r == '’') {
			maybe = true
			maybeChar = r
		} else {
			completeToken = true
			break
		}
		i += l
	}
	if completeToken || atEOF {
		if maybe {
			i -= len(string(maybeChar))
		}
		return i, token, nil
	} else {
		return 0, nil, nil
	}
}

func main() {
	data, _ := ioutil.ReadFile("data/warandpeace.txt")
	scanner := bufio.NewScanner(bytes.NewReader(data))
	scanner.Split(scanWords)
	wordmap := map[string]bool{}
	for scanner.Scan() {
		wordmap[scanner.Text()] = true
	}
	words := []string(nil)
	for word := range wordmap {
		words = append(words, word)
	}
	for _, word := range words {
		if _, ok := wordmap[strings.ToLower(word)]; ok && (word != strings.ToLower(word)) {
			delete(wordmap, word)
		}
	}

	words = []string(nil)
	for word := range wordmap {
		words = append(words, word)
	}
	sort.Strings(words)

	out := fmt.Sprintf("%#v", words)
	out = strings.Replace(out, "{\"", "{\n\t\"", 1)
	out = strings.Replace(out, "\", \"", "\",\n\t\"", -1)
	out = strings.Replace(out, "\"}", "\",\n}\n", 1)
	out = `// Code generated by data/genwords.go - DO NOT EDIT.
package wordsandpieces // import "github.com/quitehimself/wordsandpieces"

var Words = ` + out
	ioutil.WriteFile("words.go", []byte(out), 0600)

}
